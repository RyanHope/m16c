define endian=little;

define alignment=1;

define space ram type=ram_space size=4 default;
define space near type=ram_space      size=2;
define space register type=register_space size=2;

define register offset=0x01 size=3 [ INTB];
define register offset=0x00 size=2 [ INTBH INTBL];
define register offset=0x30 size=4 [ PC];


define register offset=0x50 size=2 [ R0 R2 R1 R3 A0 A1 USP ISP SB FLAG SP FB];
define register offset=0x50 size=4 [ R2R0 R3R1 A1A0];
define register offset=0x50 size=1 [ R0L R0H _ _ R1L R1H _ _  _ _ _ _ ];

define register offset=0x100 size=1 [Cflg Dflg Zflg Sflg Bflg Oflg Iflg Uflg IPLflg];
define register offset=0x120 size=4  [ contextreg ];

define token operand_g (16)
	size0        = ( 0, 0)
	op1_7        = ( 1, 7)
	op0_7        = ( 0, 7)
	dest8_11     = ( 8,11)
	dest8_11b    = ( 8,11)
	op8_11       = ( 8,11)
	imm8_11      = ( 8,11)
	shl_imm8_11  = ( 8,11)
	cnd8_11      = ( 8,11)
	op12_15      = (12,15)
	src12_15     = (12,15)
	src12_15b    = (12,15)
	imm12_15     = (12,15)
	sha_imm12_15 = (12,15)
	op0_15       = ( 0,15)
	op8_15       = ( 8,15)
	flg12_14     = (12,14)
	ldc12_14     = (12,14)
	imm8_10      = ( 8,10)
	dest12_14    = (12,14)
	dest_SHAL_12 = (12,12)
	src32_8_11   = ( 8,11)
	mul8_11      = ( 8,11)
	mul8b8_11    = ( 8,11)
	srcb12_13    = (12,13)
	srcw12_13    = (12,13)
	dir          = (12,13)
	op13_15      = (13,15)
	bit8         = (8,8)
	bit9         = (9,9)
	bit10        = (10,10)
	bit11        = (11,11)
	bit12        = (12,12)
	bit13        = (13,13)
	bit14        = (14,14)
	bit15        = (15,15)
;

define token operand_s (8)
	op            = (3,7)
	op4_7         = (4,7)
	dest0_2       = (0,2)
	dest2_2       = (2,2)
	dest2_a0_a1   = (2,2)
	src2          = (0,1)
	bit0_2        = (0,2)
	ops0_7        = (0,7)
	dest_a0_a1    = (3,3)
	dest3_r0l_r0h = (3,3)
	cnd0_2        = (0,2)
	dsp0_2        = (0,2)
	dest0_1       = (0,1)
;

define token data8 (8)
	dsp8         = (0,7) signed
	imm8         = (0,7)
	cnd8         = (0,7)
	interrupt    = (0,5)
	data8_bits47 = (4,7)
	data8_bit6   = (6,6)
	data8_bit7   = (7,7)
	bitNo8       = (0,2)
	bitBase8     = (3,7)
;

define token dest_data8 (8)
	dest_dsp8 = (0,7) signed
	dest_imm8 = (0,7)
	dest_cnd8 = (0,7)
;

define token data16 (16)
	dsp16 = (0,15) signed
	abs16 = (0,15)
	imm16 = (0,15)
	bitNo16 = (0,2)
	bitBase16 = (3,15)
;

define token dest_data16 (16)
	dest_dsp16 = (0,15) signed
	dest_abs16 = (0,15)
	dest_imm16 = (0,15)
;

define token data32 (24)
	abs20 = (0,19)
	dsp20 = (0,19)
;

define token operand_s_imm8 (16)
	op3_7_imm8   = (3, 7)
	dest0_2_imm8 = (0, 2)
	imm8_15      = (8,15)
;

define context contextreg
	guard    = (0, 0)
	destmode = (1, 4)
	srcmode  = (5, 8)
	addrmode = (9,12)
;

# some magic, see details in .pspec file
define pcodeop segment;


attach variables [dest8_11 src12_15] [R0 R1 R2 R3 A0 A1 A0 A1 A0 A1 SB _ A0 A1 SB _ ];
attach variables [src32_8_11 mul8_11] [R2R0 R3R1 _ _ A1A0 _ _ _ _ _ _ _ _ _ _ _];
attach variables [mul8b8_11] [R0L R0H R1L R1H _ _ _ _ _ _ _ _ _ _ _ _];
attach variables [dest2_2] [R0L R0H];
attach variables [dest3_r0l_r0h] [R0L R0H];
attach variables [dest2_a0_a1 dest_a0_a1] [A0 A1];
attach variables [flg12_14] [Cflg Dflg Zflg Sflg Bflg Oflg Iflg Uflg];
attach variables [dest12_14] [R0 R1 R2 R3 A0 A1 _ _];
attach variables [dest_SHAL_12] [R2R0 R3R1];

attach values [imm8_11 imm12_15] [0 1 2 3 4 5 6 7 -8 -7 -6 -5 -4 -3 -2 -1];
attach values [shl_imm8_11 sha_imm12_15] [1 2 3 4 5 6 7 8 -1 -2 -3 -4 -5 -6 -7 -8];

attach variables [ldc12_14] [_ INTBL INTBH FLAG ISP USP SB FB];

attach variables [srcb12_13] [R0L R0H R1L R1H];
attach variables [srcw12_13] [R0 R1 R2 R3];

# destination types 8..15; used by d_eaw1 and d_eab1
d_addr: dsp8[A0]   is A0 & destmode=8; dsp8   { local temp:2 = A0 + dsp8; export temp; }
d_addr: dsp8[A1]   is A1 & destmode=9; dsp8   { local temp:2 = A1 + dsp8; export temp; }
d_addr: dsp8[SB]   is SB & destmode=10; dsp8  { local temp:2 = SB + dsp8; export temp; } 
d_addr: dsp8[FB]   is FB & destmode=11; dsp8  { local temp:2 = FB + sext(dsp8:1); export temp; } 
d_addr: dsp16[A0]  is A0 & destmode=12; dsp16 { local temp:2 = A0 + dsp16; export temp; } 
d_addr: dsp16[A1]  is A1 & destmode=13; dsp16 { local temp:2 = A1 + dsp16; export temp; } 
d_addr: dsp16[SB]  is SB & destmode=14; dsp16 { local temp:2 = SB + dsp16; export temp; } 
d_addr: abs16      is destmode=15; abs16      { local temp:2 = abs16; export temp; }

# source types 8..15; used by s_eaw1 and s_eab1
s_addr: dsp8[A0]   is A0 & srcmode=8; dsp8   { local temp:2 = A0 + dsp8; export temp; }
s_addr: dsp8[A1]   is A1 & srcmode=9; dsp8   { local temp:2 = A1 + dsp8; export temp; }
s_addr: dsp8[SB]   is SB & srcmode=10; dsp8  { local temp:2 = SB + dsp8; export temp; } 
s_addr: dsp8[FB]   is FB & srcmode=11; dsp8  { local temp:2 = FB + sext(dsp8:1); export temp; } 
s_addr: dsp16[A0]  is A0 & srcmode=12; dsp16 { local temp:2 = A0 + dsp16; export temp; } 
s_addr: dsp16[A1]  is A1 & srcmode=13; dsp16 { local temp:2 = A1 + dsp16; export temp; } 
s_addr: dsp16[SB]  is SB & srcmode=14; dsp16 { local temp:2 = SB + dsp16; export temp; } 
s_addr: abs16      is srcmode=15; abs16      { local temp:2 = abs16; export temp; }

# universal destination, dword size
d_eal1: R2R0      is R2R0 & destmode=0       { export R2R0; }
d_eal1: R3R1      is R3R1 & destmode=1       { export R3R1; }
d_eal1: A1A0      is A1A0 & destmode=4       { export A1A0; }
d_eal1: [A0]      is A0 & destmode=6         { export *:4 A0; }
d_eal1: [A1]      is A1 & destmode=7         { export *:4 A1; }
d_eal1: d_addr    is d_addr                  { local temp = d_addr; export *[near]:4 temp; }

# universal destination, word size
d_eaw1: R0         is R0 & destmode=0        { export R0; }
d_eaw1: R1         is R1 & destmode=1        { export R1; }
d_eaw1: R2         is R2 & destmode=2        { export R2; }
d_eaw1: R3         is R3 & destmode=3        { export R3; }
d_eaw1: A0         is A0 & destmode=4        { export A0; }
d_eaw1: A1         is A1 & destmode=5        { export A1; }
d_eaw1: [A0]       is A0 & destmode=6        { export *[near]:2 A0; }
d_eaw1: [A1]       is A1 & destmode=7        { export *[near]:2 A1; }
d_eaw1: d_addr     is d_addr                 { local temp = d_addr; export *[near]:2 temp; }

# universal destination, byte size
d_eab1: R0L        is destmode=0 & R0L       { export R0L; }
d_eab1: R0H        is destmode=1 & R0H       { export R0H; }
d_eab1: R1L        is destmode=2 & R1L       { export R1L; }
d_eab1: R1H        is destmode=3 & R1H       { export R1H; }
d_eab1: A0         is A0 & destmode=4        { local temp = (A0:1); export temp; }
d_eab1: A1         is A1 & destmode=5        { local temp = (A1:1); export temp; }
d_eab1: [A0]       is A0 & destmode=6        { local temp = A0; export *[near]:1 temp; }
d_eab1: [A1]       is A1 & destmode=7        { local temp = A1; export *[near]:1 temp; }
d_eab1: d_addr     is d_addr                 { local temp = d_addr; export *[near]:1 temp; }

# universal source, word size
s_eaw1: R0         is R0 & srcmode=0         { export R0; }
s_eaw1: R1         is R1 & srcmode=1         { export R1; }
s_eaw1: R2         is R2 & srcmode=2         { export R2; }
s_eaw1: R3         is R3 & srcmode=3         { export R3; }
s_eaw1: A0         is A0 & srcmode=4         { export A0; }
s_eaw1: A1         is A1 & srcmode=5         { export A1; }
s_eaw1: [A0]       is A0 & srcmode=6         { export *[near]:2 A0; }
s_eaw1: [A1]       is A1 & srcmode=7         { export *[near]:2 A1; }
s_eaw1: s_addr     is s_addr                 { local temp = s_addr; export *[near]:2 temp; }

# universal source, byte size
s_eab1: R0L        is srcmode=0 & R0L        { export R0L; }
s_eab1: R0H        is srcmode=1 & R0H        { export R0H; }
s_eab1: R1L        is srcmode=2 & R1L        { export R1L; }
s_eab1: R1H        is srcmode=3 & R1H        { export R1H; }
s_eab1: A0         is A0 & srcmode=4         { local temp = (A0:1); export temp; }
s_eab1: A1         is A1 & srcmode=5         { local temp = (A1:1); export temp; }
s_eab1: [A0]       is A0 & srcmode=6         { local temp = A0; export *[near]:1 temp; }
s_eab1: [A1]       is A1 & srcmode=7         { local temp = A1; export *[near]:1 temp; }
s_eab1: s_addr     is s_addr                 { local temp = s_addr; export *[near]:1 temp; }

# universal operands for one-operand instructions
d_eaw: d_eaw1      is op8_11 ;  d_eaw1 [ destmode = op8_11; ] { export d_eaw1; }
d_eab: d_eab1      is op8_11 ;  d_eab1 [ destmode = op8_11; ] { export d_eab1; }
s_eab: s_eab1      is op12_15 ; s_eab1 [ srcmode = op12_15; ] { export s_eab1; }


SRC2: R0L          is src2=0x00 & dest2_2=1 & R0L { export R0L; }
SRC2: R0H          is src2=0x00 & dest2_2=0 & R0H { export R0H; }
SRC2: dsp8[SB]     is src2=1 & SB; dsp8           { local temp = (SB + dsp8); export *[near]:1 temp; }
SRC2: dsp8[FB]     is src2=2  & FB; dsp8          { local temp = FB + sext(dsp8:1); export *[near]:1 temp; }
SRC2: abs16        is src2=3; abs16               { export *[near]:1 abs16; }

d_d_eab: R0H       is R0H & dest0_2=3          { export R0H; }
d_d_eab: R0L       is R0L & dest0_2=4          { export R0L; }
d_d_eab: dsp8[SB]  is SB & dest0_2=5;dsp8      { local temp = (SB +dsp8); export *[near]:1 temp; }
d_d_eab: dsp8[FB]  is FB & dest0_2=6;dsp8      { local temp = FB + sext(dsp8:1); export *[near]:1 temp; }
d_d_eab: abs16     is dest0_2=7;abs16          { export *[near]:1 abs16; }

d_imm: R0H         is R0H & dest0_2_imm8=3     { export R0H; }
d_imm: R0L         is R0L & dest0_2_imm8=4     { export R0L; }
d_imm: dsp8[SB]    is SB & dest0_2_imm8=5;dsp8 { local temp = (SB +dsp8); export *[near]:1 temp; }
d_imm: dsp8[FB]    is FB & dest0_2_imm8=6;dsp8 { local temp = FB + sext(dsp8:1); export *[near]:1 temp; }
d_imm: abs16       is dest0_2_imm8=7;abs16     { export *[near]:1 abs16; }

# EXTS.b operand
j_n_eaw: [A0]       is A0 & dest8_11=6         { local temp:2 = A0; export temp; }
j_n_eaw: [A1]       is A1 & dest8_11=7         { local temp:2 = A1; export temp; }
j_n_eaw: dsp8[A0]   is A0 & dest8_11=8; dsp8   { local temp:2 = A0 + dsp8; export temp; }
j_n_eaw: dsp8[A1]   is A1 & dest8_11=9; dsp8   { local temp:2 = A1 + dsp8; export temp; } 
j_n_eaw: dsp8[SB]   is SB & dest8_11=10; dsp8  { local temp:2 = SB + dsp8; export temp; } 
j_n_eaw: dsp8[FB]   is FB & dest8_11=11 ; dsp8 { local temp:2 = FB+sext(dsp8:1); export temp; } 
j_n_eaw: dsp16[A0]  is A0 & dest8_11=12; dsp16 { local temp:2 = A0 + dsp16; export temp; } 
j_n_eaw: dsp16[A1]  is A1 & dest8_11=13; dsp16 { local temp:2 = A1 + dsp16; export temp; } 
j_n_eaw: dsp16[SB]  is SB & dest8_11=14; dsp16 { local temp:2 = SB + dsp16; export temp; } 
j_n_eaw: abs16      is dest8_11=15; abs16      { local temp:2 = abs16; export temp; }

# JMPI.w, JSRI.w, JSRI.a operand
j_eaw: [A0]         is A0 & dest8_11=6         { local temp:4 = zext(A0); export *:2 temp; }
j_eaw: [A1]         is A1 & dest8_11=7         { local temp:4 = zext(A1); export *:2 temp; }
j_eaw: dsp8[A0]     is A0 & dest8_11=8; dsp8   { local temp:4 = zext(A0 + dsp8); export *:2 temp; }
j_eaw: dsp8[A1]     is A1 & dest8_11=9; dsp8   { local temp:4 = zext(A1 + dsp8); export *:2 temp; }
j_eaw: dsp8[SB]     is SB & dest8_11=10; dsp8  { local temp:4 = zext(SB + dsp8); export *:2 temp; }
j_eaw: dsp8[FB]     is FB & dest8_11=11 ; dsp8 { local temp:4 = zext(FB+sext(dsp8:1)); export *:2 temp; }
j_eaw: dsp20[A0]    is A0 & dest8_11=12; dsp20 { local temp:4 = zext(zext(A0) + dsp20:3); export *:2 temp; }
j_eaw: dsp20[A1]    is A1 & dest8_11=13; dsp20 { local temp:4 = zext(zext(A1) + dsp20:3); export *:2 temp; }
j_eaw: dsp16[SB]    is SB & dest8_11=14; dsp16 { local temp:4 = zext(SB + dsp16:2); export *:2 temp; }
j_eaw: abs16        is dest8_11=15; abs16      { local temp:4 = zext(abs16:2); export *:2 temp; }

# Bit manipulating instructions, byte address
# R0, R1, R2, R3, A0, A1
s_bitV: imm8,dest8_11   is dest8_11 & op8_11=0; imm8 & data8_bits47=0 { local addr = &R0 + (imm8 / 8); export *[register]:1 addr; }
s_bitV: imm8,dest8_11   is dest8_11 & op8_11=1; imm8 & data8_bits47=0 { local addr = &R1 + (imm8 / 8); export *[register]:1 addr; }
s_bitV: imm8,dest8_11   is dest8_11 & op8_11=2; imm8 & data8_bits47=0 { local addr = &R2 + (imm8 / 8); export *[register]:1 addr; }
s_bitV: imm8,dest8_11   is dest8_11 & op8_11=3; imm8 & data8_bits47=0 { local addr = &R3 + (imm8 / 8); export *[register]:1 addr; }
s_bitV: imm8,dest8_11   is dest8_11 & op8_11=4; imm8 & data8_bits47=0 { local addr = &A0 + (imm8 / 8); export *[register]:1 addr; }
s_bitV: imm8,dest8_11   is dest8_11 & op8_11=5; imm8 & data8_bits47=0 { local addr = &A1 + (imm8 / 8); export *[register]:1 addr; }
# [A0], [A1]
s_bitV: [dest8_11]      is dest8_11 & (op8_11=6 | op8_11=7)           { local addr = dest8_11/8; export *[near]:1 addr; }
# base8[A0], base8[A1]
s_bitV: imm8[dest8_11]  is dest8_11 & (op8_11=8 | op8_11=9); imm8     { local addr = (dest8_11 + imm8)/8; export *[near]:1 addr; }
s_bitV: bitNo8, bitBase8[SB] is SB & op8_11=10; bitNo8 & bitBase8     { local addr = SB + bitBase8; export *[near]:1 addr; }
s_bitV: bitNo8, bitBase8[FB] is FB & op8_11=11; bitNo8 & bitBase8     { local addr = FB + bitBase8; export *[near]:1 addr; }
# base16[A0], base16[A1]
s_bitV: imm16[dest8_11] is dest8_11 & (op8_11=12 | op8_11=13); imm16  { local addr = (dest8_11 + imm16)/8; export *[near]:1 addr; }
s_bitV: bitNo16, bitBase16[SB] is SB & op8_11=14; bitNo16 & bitBase16 { local addr = FB + bitBase16; export *[near]:1 addr; }
s_bitV: bitNo16, bitBase16     is op8_11=15; bitNo16 & bitBase16      { export *[near]:1 bitBase16; }

# Bit manipulating instructions, bit mask
# R0, R1, R2, R3, A0, A1
s_bitB: imm8,dest8_11   is dest8_11 & (op8_11=0 | op8_11=1 | op8_11=2 | op8_11=3 | op8_11=4 | op8_11=5); imm8 & data8_bits47=0 { local mask:1 = 1<<(imm8 & 7); export mask; }
# [A0], [A1]
s_bitB: [dest8_11]      is dest8_11 & (op8_11=6 | op8_11=7)           { local mask:1 = 1<<(dest8_11 & 3); export mask; }
# base8[A0], base8[A1]
s_bitB: imm8[dest8_11]  is dest8_11 & (op8_11=8 | op8_11=9); imm8     { local mask:1 = 1<<(imm8 & 3); export mask; }
s_bitB: bitNo8, bitBase8[SB] is SB & op8_11=10; bitNo8 & bitBase8     { local mask:1 = 1<<bitNo8; export mask; }
s_bitB: bitNo8, bitBase8[FB] is FB & op8_11=11; bitNo8 & bitBase8     { local mask:1 = 1<<bitNo8; export mask; }
# base16[A0], base16[A1]
s_bitB: imm16[dest8_11] is dest8_11 & (op8_11=12 | op8_11=13); imm16  { local mask:1 = 1<<(imm16 & 3); export mask; }
s_bitB: bitNo16, bitBase16[SB] is SB & op8_11=14; bitNo16 & bitBase16 { local mask:1 = 1<<bitNo16; export mask; }
s_bitB: bitNo16, bitBase16     is op8_11=15; bitNo16 & bitBase16      { local mask:1 = 1<<bitNo16; export mask; }


# BMxxx condition
COND8: "GEU/C"   is cnd8=0x00    { local tmp:1 = Cflg; export tmp; }
COND8: "GTU"     is cnd8=0x01    { local tmp:1 = (Cflg && !Zflg); export tmp; }
COND8: "EQ/Z"    is cnd8=0x02    { local tmp:1 = Zflg == 1; export tmp; }
COND8: "N"       is cnd8=0x03    { local tmp:1 = Sflg; export tmp; }
COND8: "LE"      is cnd8=0x04    { local tmp:1 = Zflg || (Oflg != Sflg); export tmp; }
COND8: "O"       is cnd8=0x05    { local tmp:1 = Oflg; export tmp; }
COND8: "GE"      is cnd8=0x06    { local tmp:1 = (Oflg == Sflg); export tmp; }
COND8: "LTU/NC"  is cnd8=0xf8    { local tmp:1 = !Cflg; export tmp; }
COND8: "LEU"     is cnd8=0xf9    { local tmp:1 = (!Cflg || Zflg); export tmp; }
COND8: "NE/NZ"   is cnd8=0xfa    { local tmp:1 = Zflg == 0; export tmp; }
COND8: "PZ"      is cnd8=0xfb    { local tmp:1 = !Sflg; export tmp; }
COND8: "GT"      is cnd8=0xfc    { local tmp:1 = !Zflg && (Oflg == Sflg); export tmp; }
COND8: "NO"      is cnd8=0xfd    { local tmp:1 = !Oflg; export tmp; }
COND8: "LT"      is cnd8=0xfe    { local tmp:1 = (Oflg != Sflg); export tmp; }

# BMxxx, Jxxx condition
#COND4: "GEU/C"   is cnd8_11=0x00 { local tmp:1 = Cflg; export tmp; }
#COND4: "GTU"     is cnd8_11=0x01 { local tmp:1 = Cflg==!Zflg; export tmp; }
#COND4: "EQ/Z"    is cnd8_11=0x02 { local tmp:1 = Zflg; export tmp; }
#COND4: "N"       is cnd8_11=0x03 { local tmp:1 = Sflg; export tmp; }
#COND4: "LTU/NC"  is cnd8_11=0x04 { local tmp:1 = !Cflg; export tmp; }
#COND4: "LEU"     is cnd8_11=0x05 { local tmp:1 = !(Cflg==!Zflg); export tmp; }
#COND4: "NE/NZ"   is cnd8_11=0x06 { local tmp:1 = !Zflg; export tmp; }
#COND4: "PZ"      is cnd8_11=0x07 { local tmp:1 = !Sflg; export tmp; }
COND4: "LE"      is cnd8_11=0x08 { local tmp:1 = Zflg || (Oflg != Sflg); export tmp; }
COND4: "O"       is cnd8_11=0x09 { local tmp:1 = Oflg; export tmp; }
COND4: "GE"      is cnd8_11=0x0A { local tmp:1 = (Oflg == Sflg); export tmp; }
COND4: "GT"      is cnd8_11=0x0C { local tmp:1 = !Zflg && (Oflg == Sflg); export tmp; }
COND4: "NO"      is cnd8_11=0x0D { local tmp:1 = !Oflg; export tmp; }
COND4: "LT"      is cnd8_11=0x0E { local tmp:1 = (Oflg != Sflg); export tmp; }

# Jxxx condition
COND3: "GEU/C"   is cnd0_2=0x00  { local tmp:1 = Cflg; export tmp; }
COND3: "GTU"     is cnd0_2=0x01  { local tmp:1 = (Cflg && !Zflg); export tmp; }
COND3: "EQ/Z"    is cnd0_2=0x02  { local tmp:1 = Zflg; export tmp; }
COND3: "N"       is cnd0_2=0x03  { local tmp:1 = Sflg; export tmp; }
COND3: "LTU/NC"  is cnd0_2=0x04  { local tmp:1 = !Cflg; export tmp; }
COND3: "LEU"     is cnd0_2=0x05  { local tmp:1 = (!Cflg || Zflg); export tmp; }
COND3: "NE/NZ"   is cnd0_2=0x06  { local tmp:1 = !Zflg; export tmp; }
COND3: "PZ"      is cnd0_2=0x07  { local tmp:1 = !Sflg; export tmp; }


macro macro_adc8(src, dest) {
	local tmp = dest + src + Cflg;
	Cflg = (tmp > 255);
	Zflg = (tmp == 0);
	Sflg = (tmp s< 0);
	Oflg = (tmp s< -128) | (tmp s> 127);
	dest = tmp;
}

macro macro_adc16(src, dest) {
	local s = src;
	local d = dest;
	local c:2 = zext(Cflg);
	Cflg = carry(d, src) || carry(s + d, c);
	Oflg = scarry(d, s) || scarry(s + d, c);
	d = s + d + c;
	Zflg = (d == 0);
	Sflg = (d s< 0);
	dest = d;
}

macro macro_add(src, dest) {
	local s = src;
	local d = dest;
	Cflg = carry(d, s);
	Oflg = scarry(d, s);
	d = d + s;
	Zflg = (d == 0);
	Sflg = (d s< 0);
	dest = d;
}

macro macro_and (src, dest) {
	local tmp = dest & src;
	Sflg = (tmp s< 0);
	Zflg = (tmp == 0);
	dest = tmp;
}

macro macro_bm(cond, bit, dest) {
	if (cond == 1) goto <true>;
	dest = dest & ~(1 << zext(bit));
	goto <end>;
	<true>
	dest = dest | (1 << zext(bit));
	<end>
}

macro macro_cmp(src, dest) {
	local s = src;
	local d = dest;
	local tmp = d - s;
	Cflg = (d >= s);
	Zflg = (d == s);
	Sflg = (tmp s< 0);
	Oflg = sborrow(d, s);
	dest = d;
}

macro macro_mov(src, dest) {
	local tmp = src;
	Sflg = (tmp s< 0);
	Zflg = (tmp == 0);
	dest = tmp;
}

macro macro_not(dest) {
	local tmp = ~dest;
	Sflg = (tmp s< 0);
	Zflg = (tmp == 0);
	dest = tmp;
}

macro macro_or(src, dest) {
	local tmp = dest | src;
	Sflg = (tmp s< 0);
	Zflg = (tmp == 0);
	dest = tmp;
}

macro macro_sbb8(src, dest) {
	local tmp = dest-(src-Cflg);
	Cflg = (tmp s>= 0);
	Zflg = (tmp == 0);
	Sflg = (tmp s< 0);
	Oflg = (tmp s< -128) | (tmp s> 127);
	dest = tmp;
}

macro macro_sbb16(src, dest) {
	local tmp = dest-(src+zext(Cflg));
	Cflg = (tmp s>= 0);
	Zflg = (tmp == 0);
	Sflg = (tmp s< 0);
	Oflg = (tmp s< -32768) | (tmp s> 32767);
	dest = tmp;
}

macro macro_sub(src, dest) {
	local s = src;
	local d = dest;
	local tmp = d - s;
	Cflg = (tmp s>= 0);
	Zflg = (tmp == 0);
	Sflg = (tmp s< 0);
	Oflg = sborrow(d, s);
	dest = tmp;
}

@define DEST_IS_An "(dest8_11=4 | dest8_11=5)"

@define SRCDEST8  "op8_11 & op12_15 ; s_eab1 ; d_eab1 [srcmode=op12_15; destmode=op8_11;]"

@define SRCDEST16 "op8_11 & op12_15 ; s_eaw1 ; d_eaw1 [srcmode=op12_15; destmode=op8_11;]"

u8:  "#"imm8    is imm8  { export *[const]:1 imm8; }
u16: "#"imm16   is imm16 { export *[const]:2 imm16; }



:ABS.b d_eab           is (op1_7=0x3b & size0=0 & op12_15=0xf) ... & d_eab {
	local tmp = d_eab;
	tmp = (tmp s> 0)*tmp - (tmp s< 0)*tmp;
	d_eab = tmp;
}

:ABS.w d_eaw           is (op1_7=0x3b & size0=1 & op12_15=0xf) ... & d_eaw {
	local tmp = d_eaw;
	tmp = zext(tmp s> 0)*tmp - zext(tmp s< 0)*tmp;
	d_eaw = tmp;
}


:ADC.b u8, dest8_11               is op1_7=0x3b & size0=0 & op12_15=0x6 & dest8_11 & $(DEST_IS_An); u8 {
	macro_adc16(zext(u8:1), dest8_11);
}

:ADC.b u8, d_eab                  is (op1_7=0x3b & size0=0 & op12_15=0x6) ... & d_eab; u8 {
	macro_adc8(u8, d_eab);
}

:ADC.w u16, d_eaw                is (op1_7=0x3b & size0=1 & op12_15=0x6) ... & d_eaw; u16 {
	macro_adc16(u16, d_eaw);
}

:ADC.b s_eab, dest8_11           is (op1_7=0x58 & size0=0 & dest8_11 & $(DEST_IS_An)) ...& s_eab {
	macro_adc16(zext(s_eab), dest8_11);
}

:ADC.b s_eab1, d_eab1            is op1_7=0x58 & size0=0 & $(SRCDEST8) {
	macro_adc8(s_eab1, d_eab1);
}

:ADC.w s_eaw1, d_eaw1            is op1_7=0x58 & size0=1 & $(SRCDEST16) {
	macro_adc16(s_eaw1, d_eaw1);
}

:ADCF.b d_eab                    is (op1_7=0x3b & size0=0 & op12_15=0xe) ... & d_eab {
	local c:1 = Cflg;
	macro_add(c, d_eab);
}
:ADCF.w d_eaw                    is (op1_7=0x3b & size0=1 & op12_15=0xe) ... & d_eaw {
	macro_adc16(0, d_eaw);
}

:ADD.b u8, dest8_11              is op1_7=0x3b & size0=0 & op12_15=0x04 & dest8_11 & $(DEST_IS_An); u8 {
	macro_add(zext(u8:1), dest8_11);
}

:ADD.b u8, d_eab                 is (op1_7=0x3b & size0=0 & op12_15=0x04) ...& d_eab; u8 {
	macro_add(u8, d_eab);
}

:ADD.w u16, d_eaw                is (op1_7=0x3b & size0=1 & op12_15=0x04) ... & d_eaw; u16 {
	macro_add(u16, d_eaw);
}

:ADD.b imm12_15, dest8_11        is op1_7=0x64 & size0=0 & imm12_15 & dest8_11 & $(DEST_IS_An) {
	macro_add(zext(imm12_15:1), dest8_11);
}

:ADD.b imm12_15, d_eab           is (op1_7=0x64 & size0=0 & imm12_15) ... & d_eab {
	macro_add(imm12_15, d_eab);
}

:ADD.w imm12_15, d_eaw           is (op1_7=0x64 & size0=1 & imm12_15) ... & d_eaw {
	macro_add(imm12_15, d_eaw);
}

:ADD.b imm8_15, d_imm            is (op3_7_imm8=0x10 & imm8_15) ... & d_imm {
	macro_add(imm8_15, d_imm);
}

:ADD.b s_eab1, d_eab1            is op1_7=0x50 & size0=0 & $(SRCDEST8){
	macro_add(s_eab1, d_eab1);	
}

:ADD.w s_eaw1, d_eaw1            is op1_7=0x50 & size0=1 & $(SRCDEST16) {
	macro_add(s_eaw1, d_eaw1);
}

:ADD.b SRC2, dest2_2             is (op=0x04 & dest2_2) ... & SRC2 {
	macro_add(SRC2, dest2_2);
}

:ADD.b u8, SP                    is op1_7=0x3E & size0=0 & op12_15=0xE & op8_11=0x0b & SP; u8 {
	macro_add(sext(u8:1), SP);
}

:ADD.w u16, SP                   is op1_7=0x3E & size0=1 & op12_15=0xE & op8_11=0x0b & SP ; u16 {
	macro_add(u16, SP);
}

:ADD imm8_11,SP                  is op1_7=0x3E & size0 & op12_15=0xb & imm8_11 & SP {
	macro_add(sext(imm8_11:1), SP);
}

ADJNZ_DEST: addr                 is dsp8 [addr = dsp8 + (inst_start + 2);] {
	export *:3 addr;
}

:ADJNZ.b imm12_15, d_eab, ADJNZ_DEST  is (op1_7=0x7c & size0=0 & imm12_15) ... & d_eab; ADJNZ_DEST {
	d_eab = d_eab + imm12_15;
	if(d_eab != 0) goto ADJNZ_DEST;
}

:ADJNZ.w imm12_15, d_eaw, ADJNZ_DEST  is (op1_7=0x7c & size0=1 & imm12_15) ... & d_eaw; ADJNZ_DEST {
	d_eaw = d_eaw + imm12_15;
	if(d_eaw != 0) goto ADJNZ_DEST;
}

:AND.b u8, d_eab                 is (op1_7=0x3b & size0=0 & op12_15=0x2) ... & d_eab; u8 {
	macro_and(u8, d_eab);
}

:AND.w u16, d_eaw                is (op1_7=0x3b & size0=1 & op12_15=0x2)...& d_eaw; u16 {
	macro_and(u16, d_eaw);
}

:AND.b imm8_15, d_imm            is (op3_7_imm8=0x12 & imm8_15) ... & d_imm {
	macro_and(imm8_15, d_imm);
}

:AND.b s_eab1, d_eab1            is op1_7=0x48 & size0=0 & $(SRCDEST8) {
	macro_and(s_eab1, d_eab1);
}

:AND.w s_eaw1, d_eaw1            is op1_7=0x48 & size0=1 & $(SRCDEST16) {
	macro_and(s_eaw1, d_eaw1);
}

:AND.b SRC2, dest2_2             is (op=0x2 & dest2_2)...& SRC2 {
	macro_and(SRC2, dest2_2);
}

:BAND s_bitV                     is (op0_7=0x7E & op12_15=0x4)... & s_bitV & s_bitB {
	Cflg = Cflg && (s_bitV & s_bitB);
}

:BCLR s_bitV                     is (op0_7=0x7E & op12_15=0x8)... & s_bitB & s_bitV {
	s_bitV = s_bitV & ~s_bitB;
}
:BCLR bit0_2, SB[dsp8]           is op=0x8 & bit0_2 & SB; dsp8 {
	local addr:2 = SB + dsp8;
	*[near]:1 addr = *[near]:1 addr & ~(1 << bit0_2);
}

:BM^COND8 s_bitV                 is (op0_7=0x7E & op12_15=0x2)... & s_bitV & s_bitB; COND8 {
	if (COND8) goto <set>;
		s_bitV = s_bitV & ~s_bitB;
		goto inst_next;
	<set>
		s_bitV = s_bitV | s_bitB;
}

:BM^COND4 Cflg                   is op1_7=0x3E & size0=1 & op12_15=0xD & COND4 & Cflg {
	Cflg = COND4;
}

:BNAND s_bitV                    is (op0_7=0x7E & op12_15=0x5)... & s_bitV & s_bitB {
	Cflg = Cflg && ((s_bitV & s_bitB) == 0);
}

:BNOR s_bitV                     is (op0_7=0x7E & op12_15=0x7)... & s_bitV & s_bitB {
	Cflg = Cflg || ((s_bitV & s_bitB) == 0);
}

:BNOT s_bitV                     is (op0_7=0x7E & op12_15=0xA)... & s_bitV & s_bitB {
	if (s_bitV & s_bitB) goto <clr>;
		s_bitV = s_bitV | s_bitB;
		goto inst_next;
	<clr>
		s_bitV = s_bitV & ~s_bitB;
}
:BNOT bit0_2, SB[dsp8]           is op=0x0A & bit0_2 & SB; dsp8 {
	local addr:2 = SB + dsp8;
	local mask:1 = (1 << bit0_2);
	local val:1 = *[near]:1 addr;
	if (val & mask) goto <clr>;
		*[near]:1 addr = val | mask;
		goto inst_next;
	<clr>
		*[near]:1 addr = val & ~mask;
}

:BNTST s_bitV                    is (op0_7=0x7E & op12_15=0x3)... & s_bitV & s_bitB {
	local tmp = (s_bitV & s_bitB) == 0;
	Zflg = tmp;
	Cflg = tmp;
}

:BNXOR s_bitV                    is (op0_7=0x7E & op12_15=0xD)... & s_bitV & s_bitB {
	Cflg = Cflg ^ ((s_bitV & s_bitB) == 0);
}

:BOR s_bitV                      is (op0_7=0x7E & op12_15=0x6)... & s_bitV & s_bitB {
	Cflg = Cflg || (s_bitV & s_bitB);
}

:BRK                             is ops0_7=0 {
}

:BSET s_bitV                     is (op0_7=0x7E & op12_15=0x9)... & s_bitB & s_bitV {
	s_bitV = s_bitV | s_bitB;
}
:BSET bit0_2, SB[dsp8]           is op=0x09 & bit0_2 & SB; dsp8 {
	local addr:2 = SB + dsp8;
	*[near]:1 addr = *[near]:1 addr | (1 << bit0_2);
}

:BTST s_bitV                     is (op0_7=0x7E & op12_15=0xB)... & s_bitV & s_bitB {
	local tmp = (s_bitV & s_bitB);
	Cflg = (tmp != 0);
	Zflg = (tmp == 0);
}
:BTST bit0_2, SB[dsp8]           is op=0x0B & bit0_2 & SB; dsp8 {
	local addr:2 = SB + dsp8;
	local newv = *[near]:1 addr & (1 << bit0_2);
	Cflg = (newv != 0);
	Zflg = (newv == 0);
}

:BTSTC s_bitV                    is (op0_7=0x7E & op12_15=0x0)... & s_bitB & s_bitV {
	local tmp = (s_bitV & s_bitB);
	Cflg = (tmp != 0);
	Zflg = (tmp == 0);
	s_bitV = s_bitV & ~s_bitB;
}

:BTSTS s_bitV                    is (op0_7=0x7E & op12_15=0x1)... & s_bitB & s_bitV {
	local tmp = (s_bitV & s_bitB);
	Cflg = (tmp != 0);
	Zflg = (tmp == 0);
	s_bitV = s_bitV | s_bitB;
}

:BXOR s_bitV                     is (op0_7=0x7E & op12_15=0xC)... & s_bitB & s_bitV {
	Cflg = Cflg ^ ((s_bitV & s_bitB) != 0);
}

:CMP.b u8, d_eab                 is (op1_7=0x3B & size0=0 & op12_15=0x08) ... & d_eab; u8 {
	macro_cmp(u8, d_eab);
}

:CMP.w u16,d_eaw                 is (op1_7=0x3B & size0=1 & op12_15=0x08) ... & d_eaw; u16 {
	macro_cmp(u16, d_eaw);
}

:CMP.b imm12_15, d_eab           is (op1_7=0x68 & size0=0 & imm12_15) ... & d_eab {
	macro_cmp(imm12_15, d_eab);
}

:CMP.w imm12_15, d_eaw           is (op1_7=0x68 & size0=1 & imm12_15) ... & d_eaw {
	macro_cmp(imm12_15, d_eaw);
}
   
:CMP.b imm8_15, d_imm            is (op3_7_imm8=0x1C & imm8_15) ... & d_imm {
	macro_cmp(imm8_15, d_imm);
}

:CMP.b s_eab1, d_eab1            is op1_7=0x60 & size0=0 & $(SRCDEST8) {
	macro_cmp(s_eab1, d_eab1);
} 

:CMP.w s_eaw1, d_eaw1            is op1_7=0x60 & size0=1 & $(SRCDEST16) {
	macro_cmp(s_eaw1, d_eaw1);
} 

:CMP.B SRC2, dest2_2             is (op=0x07 & dest2_2) ... & SRC2 {
	macro_cmp(SRC2, dest2_2);
}

#:DADC.b imm8,R0L       is op0_15=0x7CEE &R0L; imm8 {
#}
#
#:DADC.w imm16,R0       is op0_15=0x7DEE &R0; imm16 {
#}
#
#:DADC.b R0H,R0L        is op0_15=0x7CE6 & R0H &R0L {
#}
#
#:DADC.b R1,R0          is op0_15=0x7DE6 & R1 &R0 {
#}
#
#:DADD.b imm8, R0L      is op0_15=0x7CEC & R0L; imm8 {
#}
#
#:DADD.w imm16,R0       is op0_15=0x7DEC & R0; imm16 {
#}
#
#:DADD.b R0H, R0L       is op0_15=0x7CE4 & R0L & R0H {
#}
#
#:DADD.w R1, R0         is op0_15=0x7DE4 & R1 & R0 {
#}

:DEC.b d_d_eab                   is op=0x15 ... & d_d_eab {
	d_d_eab = d_d_eab-1;
	Sflg = (d_d_eab s< 0);
	Zflg = (d_d_eab == 0);
}

:DEC.w dest_a0_a1                is op4_7=0xF & dest_a0_a1 & bit0_2=0x2 {
	local tmp:2 = dest_a0_a1 -1;
	dest_a0_a1 = tmp-1;
	Sflg = (tmp s< 0);
	Zflg = (tmp == 0);
	dest_a0_a1 = tmp;
}

macro macro_DIV(dividend, divisor, quotient, remainder, result_max)
{
	local q = dividend / sext(divisor);
	local r = dividend % sext(divisor);
	Oflg = (divisor == 0) || (q s< (-result_max-1)) || (q s> result_max);
	quotient = q:2;
	remainder = r:2;
}
:DIV.b u8            is op1_7=0x3e & size0=0 & op8_15=0xe1; u8 {
	macro_DIV(R0, u8, R0L, R0H, 0x7f);
}
:DIV.w u16           is op1_7=0x3e & size0=1 & op8_15=0xe1; u16 {
	macro_DIV(R2R0, u16, R0, R2, 0x7fff);
}
:DIV.b d_eab         is (op1_7=0x3B & size0=0 & op12_15=0xD) ... & d_eab {
	macro_DIV(R0, d_eab, R0L, R0H, 0x7f);
}
:DIV.w d_eaw         is (op1_7=0x3B & size0=1 & op12_15=0xD) ... & d_eaw {
	macro_DIV(R2R0, d_eaw, R0, R2, 0x7fff);
}

macro macro_DIVU(dividend, divisor, quotient, remainder, result_max)
{
	local q = dividend / zext(divisor);
	local r = dividend % zext(divisor);
	Oflg = (divisor == 0) || (q > result_max);
	quotient = q:2;
	remainder = r:2;
}
:DIVU.b u8           is op1_7=0x3e & size0=0 & op8_15=0xe0; u8 {
	macro_DIVU(R0, u8, R0L, R0H, 0xff);
}
:DIVU.w u16          is op1_7=0x3e & size0=1 & op8_15=0xe0; u16 {
	macro_DIVU(R2R0, u16, R0, R2, 0xffff);
}
:DIVU.b d_eab        is (op1_7=0x3B & size0=0 & op12_15=0xC) ... & d_eab {
	macro_DIVU(R0, d_eab, R0L, R0H, 0xff);
}
:DIVU.w d_eaw        is (op1_7=0x3B & size0=1 & op12_15=0xC) ... & d_eaw {
	macro_DIVU(R2R0, d_eaw, R0, R2, 0xffff);
}

# FIXME find how to write this difference:
# DIV:  The remainder has the same sign as the dividend.
# DIVX: The remainder has the same sign as the divisor.
macro macro_DIVX(dividend, divisor, quotient, remainder, result_max)
{
	local q = dividend / sext(divisor);
	local r = dividend % sext(divisor);
	Oflg = (divisor == 0) || (q s< (-result_max-1)) || (q s> result_max);
	quotient = q:2;
	remainder = r:2;
}
:DIVX.b u8             is op1_7=0x3e & size0=0 & op8_15=0xe3; u8 {
	macro_DIVX(R0, u8, R0L, R0H, 0x7f);
}
:DIVX.w u16            is op1_7=0x3e & size0=1 & op8_15=0xe3; u16 {
	macro_DIVX(R2R0, u16, R0, R2, 0x7fff);
}
:DIVX.b d_eab          is (op1_7=0x3B & size0=0 & op12_15=0x9) ... & d_eab {
	macro_DIVX(R0, d_eab, R0L, R0H, 0x7f);
}
:DIVX.w d_eaw          is (op1_7=0x3B & size0=1 & op12_15=0x9) ... & d_eaw {
	macro_DIVX(R2R0, d_eaw, R0, R2, 0x7fff);
}

#:DSBB.b imm8, R0L      is op0_15=0x7CEF & R0L; imm8 {
#}
#
#:DSBB.w imm16, R0      is op0_15=0x7DEF & R0; imm16 {
#}
#
#:DSBB.b R0H, R0L       is op0_15=0x7CE7 & R0H & R0L {
#}
#
#:DSBB.w R1, R0         is op0_15=0x7DE7 & R1 & R0 {
#}
#
#:DSUB.b imm8, R0L      is op0_15=0x7CED & R0L; imm8 {
#}
#
#:DSUB.w imm16, R0      is op0_15=0x7DED & R0; imm16 {
#}
#
#:DSUB.b R0H, R0L       is op0_15=0x7CE5 & R0H &R0L {
#}
#
#:DSUB.w R1, R0         is op0_15=0x7DE5 & R1 & R0 {
#}

:ENTER imm8                        is op0_15=0xF27C;imm8 {
	SP = SP -2;
	*[near]:2 SP = FB:2;
	FB = SP;
	SP = SP - imm8;
}

:EXITD                             is op0_15=0xF27D {
	SP = FB;
	FB = *[near]:2 SP;
	SP = SP+2;
	local return_addr:3 = *[near]:2 SP;
	SP = SP+2;
	local pc_h:3 = zext(*[near]:2 SP) << 16;
	SP = SP-1;
	return_addr = return_addr & pc_h;
	return [return_addr];
}

:EXTS.b R0L                        is R0L & op0_7=0x7C & op12_15=0x06 & dest8_11=0 {
	R0 = sext(R0L);
	Sflg = (R0 s< 0);
	Zflg = (R0 == 0);
}

:EXTS.b R1L                        is R1L & op0_7=0x7C & op12_15=0x06 & dest8_11=2 {
	R1 = sext(R1L);
	Sflg = (R1 s< 0);
	Zflg = (R1 == 0);
}

:EXTS.b j_n_eaw                      is (op0_7=0x7C & op12_15=0x06) ... & j_n_eaw {
	*[near]:2 j_n_eaw = sext(*[near]:1 j_n_eaw);
	Sflg = (*[near]:2 j_n_eaw s< 0);
	Zflg = (*[near]:2 j_n_eaw == 0);
}

:EXTS.w R0                         is op0_15=0xF37C & R0 {
	R2R0 = sext(R0);
}

define pcodeop INTERRUPTS_ENABLE;
define pcodeop INTERRUPTS_DISABLE;

:FCLR flg12_14                     is op0_7=0xEB & op8_11=0x05 & bit15=0 & flg12_14 & flg12_14=6 {
	INTERRUPTS_DISABLE();
	flg12_14 = 0;
}

:FSET flg12_14                     is op0_7=0xEB & op8_11=0x04 & bit15=0 & flg12_14 & flg12_14=6 {
	INTERRUPTS_ENABLE();
	flg12_14 = 1;
}

:FCLR flg12_14                     is op0_7=0xEB & op8_11=0x05 & bit15=0 & flg12_14 {
	flg12_14 = 0;
}

:FSET flg12_14                     is op0_7=0xEB & op8_11=0x04 & bit15=0 & flg12_14 {
	flg12_14 = 1;
}


:INC.b d_d_eab                     is op=0x14 ... & d_d_eab {
	d_d_eab = d_d_eab+1;
	Sflg = (d_d_eab s< 0);
	Zflg = (d_d_eab == 0);
}

:INC.w dest_a0_a1                  is op4_7=0x0B & dest_a0_a1  & bit0_2=0x02 {
	local tmp:2 = dest_a0_a1+1;
	Sflg = (tmp s< 0);
	Zflg = (tmp == 0);
	dest_a0_a1 = tmp;
}

define pcodeop INTERRUPT;

:INT interrupt                     is ops0_7=0xEB; data8_bit6=1 & data8_bit7=1 & interrupt {
	INTERRUPT(interrupt:1);
}

:INTO                              is ops0_7=0xF6 {
}

dest: addr   is dsp8 [addr = (inst_start+1)+dsp8;] { export *:4 addr; }
dest4: addr  is dsp8 [addr = (inst_start+2)+dsp8;] { export *:4 addr; }

# TODO: Actually evalulate condition
:J^COND3 dest                      is op=0x0D & COND3; dest {
	if (COND3) goto dest;
}

:J^COND4    dest4                  is op0_7=0x7D & op12_15=0x0C & COND4; dest4 {
	if (COND4) goto dest4;
}

:JMP.s addr                        is op=0x0C & dsp0_2 [addr = (inst_start+2)+dsp0_2;] {
	goto [addr:4];
}

:JMP.b addr                        is ops0_7=0xFE; dsp8 [addr = (inst_start+1)+dsp8;] {
	goto [addr:4];
}

:JMP.w addr                        is ops0_7=0xF4; dsp16  [addr = (inst_start+1)+dsp16;] {
	goto [addr:4];
}

:JMP.A abs20                       is ops0_7=0xFC; abs20 {
	goto [abs20:4];
}



:JMPI.w j_eaw                      is (op0_7=0x7D & op12_15=0x02) ... & j_eaw {
	local addr:4 = inst_start+sext(j_eaw);
	goto [addr];
}

#:JMPI.a j_eaw          is op0_7=0x7D & op12_15=0x00 & dest8_11; j_eaw {
#	goto [j_eaw];
#}
#
#:JMPS imm8             is ops0_7=0xEE; imm8 {
#}
#
:JSR.w addr                        is ops0_7=0xF5; dsp16 [addr = dsp16+inst_start+1;] {
	SP = SP-3;
	*[near]:3 SP = inst_next;
	call [addr:3];
}

:JSR.a abs20                       is ops0_7=0xFD; abs20 {
	SP = SP-3;
	*[near]:3 SP = inst_next;
	call [abs20:3];
}
#
#:JSRI.w j_eaw          is (op0_7=0x7D & op12_15=0x03) ... & j_eaw {
#}


:JSRI.a src32_8_11                 is op0_7=0x7D & op12_15=0x01 & src32_8_11 & (src32_8_11=0 | src32_8_11=1 | src32_8_11=4){
	SP = SP-3;
	*[near]:3 SP = inst_next;
	call [src32_8_11];
}

:JSRI.a j_eaw                      is (op0_7=0x7D & op12_15=0x01) ...& j_eaw {
	SP = SP-3;
	*[near]:3 SP = inst_next;
	call [j_eaw];
}

#:JSRS imm8                        is op0_7=0xEF; imm8 {
#}

#:LDC imm16, "USP"                 is op0_7=0xEB & op8_11=0x00 & ldc12_14=5 & bit15=0; imm16 {
#	SP = zext(imm16:2);
##	SP = zext(USP);
#}

:LDC u16, ldc12_14                 is op0_7=0xEB & op8_11=0x00 & ldc12_14 & bit15=0; u16 {
	ldc12_14 = u16;
#	SP = zext(USP);
}

:LDC d_eaw, ldc12_14               is (op0_7=0x7A & ldc12_14 & bit15=1) ... & d_eaw {
	ldc12_14 = d_eaw;
}

# TODO: Implement LDCTX
define pcodeop LOAD_CONTEXT;

:LDCTX abs16, abs20                is op0_15=0xF07C; abs16; abs20 {
	LOAD_CONTEXT(abs16:2, abs20:3);
}

:LDE.b abs20, dest8_11             is op1_7=0x3A & size0=0 & op12_15=0x08 & dest8_11 & $(DEST_IS_An); abs20 {
	local addr:4 = zext(abs20:3);
	dest8_11 = zext(*:1 addr);
	Zflg = (dest8_11 == 0);
	Sflg = (dest8_11 s< 0);
}

:LDE.b abs20, d_eab                is (op1_7=0x3A & size0=0 & op12_15=0x08) ... & d_eab; abs20 {
	local addr:4 = zext(abs20:3);
	d_eab = *:1 addr;
	Zflg = (d_eab == 0);
	Sflg = (d_eab s< 0);
}

:LDE.w abs20, d_eaw                is (op1_7=0x3A & size0=1 & op12_15=0x08) ... & d_eaw; abs20 {
	local addr:4 = zext(abs20:3);
	d_eaw = *:2 addr;
	Zflg = (d_eaw == 0);
	Sflg = (d_eaw s< 0);
}

:LDE.b dsp20[A0], dest8_11         is A0 & op1_7=0x3A & size0=0 & op12_15=0x09 & dest8_11 & $(DEST_IS_An); dsp20 {
	local addr:4 = zext(zext(A0)+dsp20:3);
	local tmp:1 = *:1 addr;
	Zflg = (tmp == 0);
	Sflg = (tmp s< 0);
	dest8_11 = zext(tmp);
}

:LDE.b dsp20[A0], d_eab            is (A0 & op1_7=0x3A & size0=0 & op12_15=0x09) ... & d_eab; dsp20 {
	local addr:4 = zext(zext(A0)+dsp20:3);
	local tmp:1 = *:1 addr;
	Zflg = (tmp == 0);
	Sflg = (tmp s< 0);
	d_eab = tmp;
}

:LDE.w dsp20[A0], d_eaw            is (A0 & op1_7=0x3A & size0=1 & op12_15=0x09) ... & d_eaw; dsp20 {
	local addr:4 = zext(A0)+zext(dsp20:3);
	d_eaw = *:2 addr;
	Zflg = (d_eaw == 0);
	Sflg = (d_eaw s< 0);
}

:LDE.b A1A0, d_eab                 is (op1_7=0x3A & size0=0 & op12_15=0x0A &A1A0) ... & d_eab {
	d_eab = *:1 A1A0;
	Zflg = (d_eab == 0);
	Sflg = (d_eab s< 0);
}

:LDE.w A1A0, d_eaw                 is (op1_7=0x3A & size0=1 & op12_15=0x0A &A1A0) ... & d_eaw {
	d_eaw = *:2 A1A0;
	Zflg = (d_eaw == 0);
	Sflg = (d_eaw s< 0);
}

#
## TODO LDINTB PDF page 212
##:LDINTB
define pcodeop IPL_LOAD;

:LDIPL imm8_10                     is op0_7=0x7D & op12_15=0x0A & bit11=0 & imm8_10 {
	IPL_LOAD(imm8_10:1);
	IPLflg = imm8_10:1;
}


:MOV.b u8, d_eab                   is (op1_7=0x3A & size0=0 & op12_15=0x0C) ... & d_eab; u8 {
	macro_mov(u8, d_eab);
}

:MOV.w u16, d_eaw                  is (op1_7=0x3A & size0=1 & op12_15=0x0C) ... & d_eaw; u16 {
	macro_mov(u16, d_eaw);
}

#Handle zero extending to fill A0/A1 when moving to them
:MOV.b "#"imm12_15, dest8_11        is op1_7=0x6C & size0=0 & imm12_15 & dest8_11 & $(DEST_IS_An) {
	macro_mov(zext(imm12_15:1), dest8_11);
}

:MOV.b "#"imm12_15, d_eab           is (op1_7=0x6C & size0=0 & imm12_15) ... & d_eab {
	macro_mov(imm12_15, d_eab);
}

:MOV.w "#"imm12_15, d_eaw           is (op1_7=0x6C & size0=1 & imm12_15) ... & d_eaw {
	macro_mov(sext(imm12_15:1), d_eaw);
}

:MOV.b "#"imm8_15, d_imm            is (op3_7_imm8=0x18 & imm8_15) ... & d_imm {
	macro_mov(imm8_15, d_imm);
}

## Size is 1 for byte and 0 for word. Opposite of everything else?
:MOV.b u8, A0                       is A0 & op4_7=0x0E & bit0_2=0x02 & dest_a0_a1=0; u8 {
	macro_mov(zext(u8:1), A0);
}

:MOV.b u8, A1                       is A1 & op4_7=0x0E & bit0_2=0x02 & dest_a0_a1=1; u8 {
	macro_mov(zext(u8:1), A1);
}


# TODO: Why these need to be seperated I do not know, otherwise they would be fixed by now
# Size is 1 for byte and 0 for word. Opposite of everything else?
:MOV.w u16, A0                      is A0 & op4_7=0x0A & dest_a0_a1=0 & bit0_2=0x02; u16 {
	macro_mov(u16, A0);
}

# Size is 1 for byte and 0 for word. Opposite of everything else?
:MOV.w u16, A1                      is A1 & op4_7=0x0A & dest_a0_a1=1 & bit0_2=0x02; u16 {
	macro_mov(u16, A1);
}

ZERO: "0"  is epsilon {
	local tmp:1 = 0;
	export *[const]:1 tmp;
}

:MOV.b ZERO, d_d_eab               is op=0x16 ... & d_d_eab; ZERO {
	macro_mov(ZERO, d_d_eab);
}

#Handle zero extending to fill A0/A1 when moving to them
:MOV.b s_eab, dest8_11             is (op1_7=0x39 & size0=0 & dest8_11 & $(DEST_IS_An)) ...& s_eab {
	macro_mov(zext(s_eab:1), dest8_11);
}

:MOV.b   s_eab1, d_eab1            is op1_7=0x39 & size0=0 & $(SRCDEST8) {
	macro_mov(s_eab1, d_eab1);
}

:MOV.w s_eaw1, d_eaw1              is op1_7=0x39 & size0=1 & $(SRCDEST16) {
	macro_mov(s_eaw1, d_eaw1);
}

:MOV.b SRC2, dest2_a0_a1           is (op=0x06 & dest2_a0_a1) ... & SRC2 {
	macro_mov(zext(SRC2), dest2_a0_a1);
}

:MOV.b dest2_2,SRC2                is (op=0x00 &dest2_2) ... & SRC2 {
	macro_mov(dest2_2, SRC2);
}

:MOV.b SRC2, dest2_2               is (op=0x01 &dest2_2) ... & SRC2 {
	macro_mov(SRC2, dest2_2);
}

#Handle zero extending to fill A0/A1 when moving to them
:MOV.b dsp8[SP], dest8_11          is SP &op1_7=0x3A & size0=0 & op12_15=0x0B & dest8_11 & $(DEST_IS_An); dsp8 {
	local addr:2 = SP+sext(dsp8:1);
	macro_mov(zext(*[near]:1 addr), dest8_11);
}

:MOV.b dsp8[SP], d_eab             is (SP & op1_7=0x3A & size0=0 & op12_15=0x0B) ... & d_eab ; dsp8 {
	local addr:2 = SP+sext(dsp8:1);
	macro_mov(*[near]:1 addr, d_eab);
}

:MOV.w dsp8[SP], d_eaw             is (SP & op1_7=0x3A & size0=1 & op12_15=0x0b) ... & d_eaw; dsp8 {
	local addr:2 = SP+sext(dsp8:1);
	macro_mov(*[near]:2 addr, d_eaw);
}

:MOV.b d_eab, dsp8[SP]             is (SP & op1_7=0x3A & size0=0 & op12_15=0x03) ... & d_eab; dsp8 {
	local addr:2 = SP+sext(dsp8:1);
	local temp:1;
	macro_mov(d_eab, temp);
	*[near] addr = temp;
}

:MOV.w d_eaw, dsp8[SP]             is (SP & op1_7=0x3A & size0=1 & op12_15=0x03) ... & d_eaw; dsp8 {
	local addr:2 = SP+sext(dsp8:1);
	local temp:2;
	macro_mov(d_eaw, temp);
	*[near] addr = temp;
}

MOVA_ADDRESS: dsp8[dest8_11]   is dest8_11 & dest8_11=8; dsp8   { local addr:2 = dest8_11+zext(dsp8:1); export addr; }
MOVA_ADDRESS: dsp8[dest8_11]   is dest8_11 & dest8_11=9; dsp8   { local addr:2 = dest8_11+zext(dsp8:1); export addr; }
MOVA_ADDRESS: dsp8[dest8_11]   is dest8_11 & dest8_11=10; dsp8  { local addr:2 = dest8_11+zext(dsp8:1); export addr; }
MOVA_ADDRESS: dsp8[FB]         is FB & dest8_11=11; dsp8        { local addr:2 = FB+sext(dsp8:1); export addr; }
MOVA_ADDRESS: dsp16[dest8_11]  is dest8_11 & dest8_11=12; dsp16 { local addr:2 = dest8_11+dsp16; export addr; }
MOVA_ADDRESS: dsp16[dest8_11]  is dest8_11 & dest8_11=13; dsp16 { local addr:2 = dest8_11+dsp16; export addr; }
MOVA_ADDRESS: dsp16[dest8_11]  is dest8_11 & dest8_11=14; dsp16 { local addr:2 = dest8_11+dsp16; export addr; }
MOVA_ADDRESS: abs16            is dest8_11=15; abs16 		{ local addr:2 = abs16; export addr; }

:MOVA MOVA_ADDRESS, dest12_14      is (op0_7=0xEB & bit15=0 & dest12_14) ... & MOVA_ADDRESS {
	dest12_14 = MOVA_ADDRESS:2;
}

:MOVLL R0L, d_eab                  is (R0L & op0_7=0x7C & bit15=1 & bit14=0 & dir=0x00) ... & d_eab {
	d_eab = (d_eab & 0xF0)|(R0L & 0x0F);
}
:MOVLH R0L, d_eab                  is (R0L & op0_7=0x7C & bit15=1 & bit14=0 & dir=0x02) ... & d_eab {
	d_eab = (d_eab & 0x0F)|(R0L << 4);
}
:MOVHL R0L, d_eab                  is (R0L & op0_7=0x7C & bit15=1 & bit14=0 & dir=0x01) ... & d_eab {
	d_eab = (d_eab & 0xF0)|(R0L >> 4);
}
:MOVHH R0L, d_eab                  is (R0L & op0_7=0x7C & bit15=1 & bit14=0 & dir=0x03) ... & d_eab {
	d_eab = (d_eab & 0x0F)|(R0L & 0xF0);
}

:MOVLL d_eab, R0L                  is (R0L & op0_7=0x7C & bit15=0 & bit14=0 & dir=0x00) ... & d_eab {
	R0L = (R0L & 0xF0)|(d_eab & 0x0F);
}
:MOVLH d_eab, R0L                  is (R0L & op0_7=0x7C & bit15=0 & bit14=0 & dir=0x02) ... & d_eab {
	R0L = (R0L & 0x0F)|(d_eab << 4);
}
:MOVHL d_eab, R0L                  is (R0L & op0_7=0x7C & bit15=0 & bit14=0 & dir=0x01) ... & d_eab {
	R0L = (R0L & 0xF0)|(d_eab >> 4);
}
:MOVHH d_eab, R0L                  is (R0L & op0_7=0x7C & bit15=0 & bit14=0 & dir=0x03) ... & d_eab {
	R0L = (R0L & 0x0F)|(d_eab & 0xF0);
}

:MUL.w u16, d_eal1                is op1_7=0x3E & size0=1 & op12_15=0x05 & op8_11; d_eal1 & d_eaw1; u16 [ destmode=op8_11; ]{
	d_eal1 = sext(d_eaw1) * sext(u16);
}
:MUL.b u8, d_eaw1                 is op1_7=0x3E & size0=0 & op12_15=0x05 & op8_11; d_eaw1 & d_eab1; u8 [ destmode=op8_11; ]{
	d_eaw1 = sext(d_eab1) * sext(u8);
}
:MUL.w s_eaw1, d_eal1             is op1_7=0x3C & size0=1 & op12_15 & op8_11; s_eaw1; d_eal1 & d_eaw1
	[ destmode=op8_11; srcmode=op12_15; ]{
	d_eal1 = sext(d_eaw1) * sext(s_eaw1);
}
:MUL.b s_eab1, d_eaw1             is op1_7=0x3C & size0=0 & op12_15 & op8_11; s_eab1; d_eaw1 & d_eab1
	[ destmode=op8_11; srcmode=op12_15; ]{
	d_eaw1 = sext(d_eab1) * sext(s_eab1);
}


:MULU.w u16, d_eal1               is op1_7=0x3E & size0=1 & op12_15=0x04 & op8_11; d_eal1 & d_eaw1; u16 [ destmode=op8_11; ] {
	d_eal1 = zext(u16) * zext(d_eaw1);
}
:MULU.b u8, d_eaw1                is op1_7=0x3E & size0=0 & op12_15=0x04 & op8_11; d_eaw1 & d_eab1; u8 [ destmode=op8_11; ] {
	d_eaw1 = zext(u8) * zext(d_eab1);
}
:MULU.w s_eaw1, d_eal1            is op1_7=0x38 & size0=1 & op12_15 & op8_11; s_eaw1; d_eal1 & d_eaw1
	[srcmode=op12_15; destmode=op8_11;] {
	d_eal1 = zext(s_eaw1) * zext(d_eaw1);
}
:MULU.b s_eab1, d_eaw1            is op1_7=0x38 & size0=0 & op12_15 & op8_11; s_eab1; d_eaw1 & d_eab1
	[srcmode=op12_15; destmode=op8_11;] {
	d_eaw1 = zext(s_eab1) * zext(d_eab1);
}


:NEG.b d_eab                       is (op1_7=0x3A & size0=0 & op12_15=0x05) ... & d_eab {
	Oflg = (d_eab == -128);
	d_eab = -d_eab;
	Sflg = (d_eab s< 0);
	Zflg = (d_eab == 0);
	Cflg = (d_eab == 0);
}

:NEG.w d_eaw                       is (op1_7=0x3A & size0=1 & op12_15=0x05) ... & d_eaw {
	Oflg = (d_eaw == -32768);
	d_eaw = -d_eaw;
	Sflg = (d_eaw s< 0);
	Zflg = (d_eaw == 0);
	Cflg = (d_eaw == 0);
}

:NOP                               is ops0_7=0x04 {
}

:NOT.b dest8_11                    is op1_7=0x3A & size0=0 & op12_15=0x07 & dest8_11 & $(DEST_IS_An) {
	macro_not(dest8_11:1);
}

:NOT.b d_eab                       is (op1_7=0x3A & size0=0 & op12_15=0x07) ... & d_eab {
	macro_not(d_eab);
}

:NOT.w d_eaw                       is (op1_7=0x3A & size0=1 & op12_15=0x07) ... & d_eaw {
	macro_not(d_eaw);
}

:NOT.b d_d_eab                     is op=0x17 ... & d_d_eab {
	macro_not(d_d_eab);
}


:OR.b u8, dest8_11               is op1_7=0x3B & size0=0 & op12_15=0x03 & dest8_11 & $(DEST_IS_An); u8 {
	macro_or(zext(u8:1), dest8_11);
}

:OR.b u8, d_eab                  is (op1_7=0x3B & size0=0 & op12_15=0x03) ... & d_eab; u8 {
	macro_or(u8, d_eab);
}

:OR.w u16, d_eaw                 is (op1_7=0x3B & size0=1 & op12_15=0x03) ... & d_eaw; u16 {
	macro_or(u16, d_eaw);
}

:OR.b imm8_15, d_imm               is (op3_7_imm8=0x13 & imm8_15) ... & d_imm {
	macro_or(imm8_15, d_imm);
}

:OR.b s_eab, dest8_11              is (op1_7=0x4C & size0=0 & op12_15=0x03 & dest8_11 & $(DEST_IS_An)) ... & s_eab {
	macro_or(zext(s_eab), dest8_11);
}

:OR.b s_eab1, d_eab1               is op1_7=0x4C & size0=0 & $(SRCDEST8) {
	macro_or(s_eab1, d_eab1);
}

:OR.w s_eaw1, d_eaw1               is op1_7=0x4C & size0=1 & $(SRCDEST16) {
	macro_or(s_eaw1, d_eaw1);
}

:OR.b SRC2, dest2_2                is (op=0x03 & dest2_2) ... & SRC2 {
	macro_or(SRC2, dest2_2);
}

:POP.b d_eab                       is (op1_7=0x3A & size0=0 & op12_15=0x0D) ... & d_eab {
	d_eab = *[near]:1 SP;
	SP = SP + 1;
}

:POP.w d_eaw                       is (op1_7=0x3A & size0=1 & op12_15=0x0D) ... & d_eaw {
	d_eaw = *[near]:2 SP;
	SP = SP + 2;
}

:POP.b R0L   is R0L & op4_7=0x09 & dest3_r0l_r0h=0 &bit0_2=0x02 {
	R0L = *[near]:1 SP;
	SP = SP + 1;
}

:POP.b R0H   is R0H & op4_7=0x09 & dest3_r0l_r0h=1 &bit0_2=0x02 {
	R0H = *[near]:1 SP;
	SP = SP + 1;
}

:POP.w A0                          is A0 & op4_7=0x0D & dest_a0_a1=0 &bit0_2=0x02 {
	A0 = *[near]:2 SP;
	SP = SP + 2;
}

:POP.w A1                          is A1 & op4_7=0x0D & dest_a0_a1=1 &bit0_2=0x02 {
	A1 = *[near]:2 SP;
	SP = SP + 2;
}

:POPC ldc12_14         is op0_7=0xEB & ldc12_14 &  op8_11=0x03 {
	ldc12_14 = *[near]:2 SP;
	SP = SP + 2;
}

POPFB: FB is FB & bit15=1 {FB = *[near]:2 SP; SP = SP+2;}
POPFB:    is bit15=0 {}
POPSB: SB is SB & bit14=1 {SB = *[near]:2 SP; SP = SP+2;}
POPSB:    is bit14=0 {}
POPA1: A1 is A1 & bit13=1 {A1 = *[near]:2 SP; SP = SP+2;}
POPA1:    is bit13=0 {}
POPA0: A0 is A0 & bit12=1 {A0 = *[near]:2 SP; SP = SP+2;}
POPA0:    is bit12=0 {}
POPR3: R3 is R3 & bit11=1 {R3 = *[near]:2 SP; SP = SP+2;}
POPR3:    is bit11=0 {}
POPR2: R2 is R2 & bit10=1 {R2 = *[near]:2 SP; SP = SP+2;}
POPR2:    is bit10=0 {}
POPR1: R1 is R1 & bit9=1 {R1 = *[near]:2 SP; SP = SP+2;}
POPR1:    is bit9=0 {}
POPR0: R0 is R0 & bit8=1 {R0 = *[near]:2 SP; SP = SP+2;}
POPR0:    is bit8=0 {}

POPMDISP: POPFB POPSB POPA1 POPA0 POPR3 POPR2 POPR1 POPR0 is POPFB & POPSB & POPA1 & POPA0 & POPR3 & POPR2 & POPR1 & POPR0 {
	build POPFB;
	build POPSB;
	build POPA1;
	build POPA0;
	build POPR3;
	build POPR2;
	build POPR1;
	build POPR0;
}

:POPM POPMDISP                             is op0_7=0xED & POPMDISP {
}

:PUSH.b u8                       is op1_7=0x3E & size0=0 &op8_15=0xE2; u8 {
	SP = SP-1;
	*[near]:1 SP = u8;
}

:PUSH.w u16                      is op1_7=0x3E & size0=1 &op8_15=0xE2; u16 {
	SP = SP-2;
	*[near]:2 SP = u16;
}

:PUSH.b d_eab                      is (op1_7=0x3A &size0=0 & op12_15=0x04) ... & d_eab {
	SP = SP-1;
	*[near]:1 SP = d_eab;
}

:PUSH.w d_eaw                      is (op1_7=0x3A &size0=1 & op12_15=0x04) ... & d_eaw {
	SP = SP-2;
	*[near]:2 SP = d_eaw;
}

:PUSH.b R0L                        is R0L & op4_7=0x08 & dest3_r0l_r0h=0 & bit0_2=0x02 {
	SP = SP-1;
	*[near]:1 SP = R0L;
}

:PUSH.b R0H                        is R0H & op4_7=0x08 & dest3_r0l_r0h=1 & bit0_2=0x02 {
	SP = SP-1;
	*[near]:1 SP = R0H;
}

:PUSH.w A0                         is A0 & op4_7=0x0C & dest_a0_a1=0 & bit0_2=0x02 {
	SP = SP-2;
	*[near]:2 SP = A0;
}

:PUSH.w A1                         is A1 & op4_7=0x0C & dest_a0_a1=1 & bit0_2=0x02 {
	SP = SP-2;
	*[near]:2 SP = A1;
}

_addr: dsp8[A0]   is A0 & op8_11=8; dsp8   { local temp:2 = A0 + zext(dsp8:1); export temp; }
_addr: dsp8[A1]   is A1 & op8_11=9; dsp8   { local temp:2 = A1 + zext(dsp8:1); export temp; }
_addr: dsp8[SB]   is SB & op8_11=10; dsp8  { local temp:2 = SB + zext(dsp8:1); export temp; } 
_addr: dsp8[FB]   is FB & op8_11=11; dsp8  { local temp:2 = FB:2 + zext(dsp8:1); export temp; } 
_addr: dsp16[A0]  is A0 & op8_11=12; dsp16 { local temp:2 = A0 + dsp16:2; export temp; } 
_addr: dsp16[A1]  is A1 & op8_11=13; dsp16 { local temp:2 = A1 + dsp16:2; export temp; } 
_addr: dsp16[FB]  is FB & op8_11=14; dsp16 { local temp:2 = FB:2 + dsp16:2; export temp; } 
_addr: abs16      is op8_11=15; abs16      { local temp:2 = abs16:2; export temp; }

:PUSHA _addr                       is (op0_7=0x7D & op12_15=0x09) ... & _addr {
	SP = SP-2;
	*[near]:2 SP = _addr;
}

:PUSHC FLAG                        is FLAG & op0_7=0xEB & op8_11=0x02 & ldc12_14=0x03 & bit15=0 {
	SP = SP-2;
	local flags = (Cflg == 1) & ((Zflg == 1) << 2) & ((Sflg == 1) << 3)  & ((Bflg == 1) << 4) & ((Oflg == 1) << 5) & ((Iflg == 1) << 6) & ((Uflg == 1) << 7);
	*[near]:2 SP = zext(flags);
} 

:PUSHC ldc12_14                    is op0_7=0xEB & op8_11=0x02 & ldc12_14 & bit15=0 {
	SP = SP-2;
	*[near]:2 SP = ldc12_14;
}

PUSHFB: FB is FB & bit8=1 {SP = SP-2; *[near]:2 SP = FB;}
PUSHFB:    is bit8=0 {}
PUSHSB: SB is SB & bit8=1 {SP = SP-2; *[near]:2 SP = SB;}
PUSHSB:    is bit8=0 {}
PUSHA1: A1 is A1 & bit10=1 {SP = SP-2; *[near]:2 SP = A1;}
PUSHA1:    is bit10=0 {}
PUSHA0: A0 is A0 & bit11=1 {SP = SP-2; *[near]:2 SP = A0;}
PUSHA0:    is bit11=0 {}
PUSHR3: R3 is R3 & bit12=1 {SP = SP-2; *[near]:2 SP = R3;}
PUSHR3:    is bit12=0 {}
PUSHR2: R2 is R2 & bit13=1 {SP = SP-2; *[near]:2 SP = R2;}
PUSHR2:    is bit13=0 {}
PUSHR1: R1 is R1 & bit14=1 {SP = SP-2; *[near]:2 SP = R1;}
PUSHR1:    is bit14=0 {}
PUSHR0: R0 is R0 & bit15=1 {SP = SP-2; *[near]:2 SP = R0;}
PUSHR0:    is bit15=0 {}

PUSHMDISP: PUSHFB PUSHSB PUSHA1 PUSHA0 PUSHR3 PUSHR2 PUSHR1 PUSHR0 is PUSHFB & PUSHSB & PUSHA1 & PUSHA0 & PUSHR3 & PUSHR2 & PUSHR1 & PUSHR0 {
	build PUSHFB;
	build PUSHSB;
	build PUSHA1;
	build PUSHA0;
	build PUSHR3;
	build PUSHR2;
	build PUSHR1;
	build PUSHR0;
}

:PUSHM PUSHMDISP is op0_7=0xEC & PUSHMDISP {
	build PUSHMDISP;
}

:REIT                              is ops0_7=0xFB {
	# TODO Handle flag restoration
	SP = SP+2;
	local return_addr:3 = *[near]:2 SP;
	SP = SP+2;
	local pc_h:3 = zext(*[near]:2 SP) << 16;
	return_addr = return_addr & pc_h;
	return [return_addr];
}

#:RMPA.b                is op1_7=0x3E & size0=0 & op8_15=0xF1 {
#}
#
#:RMPA.w                is op1_7=0x3E & size0=1 & op8_15=0xF1 {
#}
#
#:ROLC.b d_eab          is (op1_7=0x3B & size0=0 & op12_15=0x0A) ... & d_eab {
#}

:ROLC.w d_eaw                      is (op1_7=0x3B & size0=1 & op12_15=0x0A) ... & d_eaw {
	local carryIn = Cflg;
	local carryout = d_eaw >> 15;
	Cflg = carryout:1;
	d_eaw = (d_eaw << 1) | zext(carryIn);
	Sflg = (d_eaw s< 0);
	Zflg = (d_eaw == 0);
}

#:RORC.b d_eab          is (op1_7=0x3B & size0=0 & op12_15=0x0B) ... & d_eab {
#}

:RORC.w d_eaw                      is (op1_7=0x3B & size0=1 & op12_15=0x0B) ... & d_eaw {
	local carryOut = Cflg << 15;
	local carryflag = d_eaw&1;
	Cflg = carryflag:1;
	d_eaw = (d_eaw >> 1) | zext(carryOut);
	Sflg = (d_eaw s< 0);
	Zflg = (d_eaw == 0);
}


# TODO FLAGS
:ROT.b sha_imm12_15, d_eab is (op1_7=0x70 & size0=0 & sha_imm12_15 & bit15=0) ... & d_eab {
	d_eab = (d_eab << sha_imm12_15)|(d_eab >> (8-sha_imm12_15));
}

:ROT.b sha_imm12_15, d_eab is (op1_7=0x70 & size0=0 & sha_imm12_15 & bit15=1) ... & d_eab {
	d_eab = (d_eab << (8-sha_imm12_15))|(d_eab >> sha_imm12_15);
}

#:ROT.w imm12_15, d_eaw is (op1_7=0x70 & size0=1 & imm12_15) ... & d_eaw {
#}
#
#:ROT.b R1H, d_eab      is (R1H & op1_7=0x3A & size0=0 & op12_15=0x06) ... & d_eab {
#}
#
#:ROT.w R1H, d_eaw      is (R1H & op1_7=0x3A & size0=1 & op12_15=0x06) ... & d_eaw {
#}


:RTS                               is ops0_7=0xF3 {
	local return_addr:3 = *[near]:3 SP;
	SP = SP+3;
	return [return_addr];
}


:SBB.b u8, dest8_11              is op1_7=0x3B & size0=0 & op12_15=0x07 & dest8_11 & $(DEST_IS_An); u8 {
	macro_sbb16(zext(u8), dest8_11);
}

:SBB.b u8, d_eab                 is (op1_7=0x3B & size0=0 & op12_15=0x07) ... & d_eab; u8 {
	macro_sbb8(u8, d_eab);
}

:SBB.w u16, d_eaw                is (op1_7=0x3B & size0=1 & op12_15=0x07) ... & d_eaw; u16 {
	macro_sbb16(u16, d_eaw);
}

:SBB.b s_eab, dest8_11             is (op1_7=0x5C & size0=0 &src12_15 & dest8_11 & $(DEST_IS_An)) ... & s_eab {
	macro_sbb16(zext(s_eab), dest8_11);
}

:SBB.b s_eab1, d_eab1              is op1_7=0x5C & size0=0 & $(SRCDEST8) {
	macro_sbb8(s_eab1, d_eab1);
}

:SBB.w s_eaw1, d_eaw1              is op1_7=0x5C & size0=1 &$(SRCDEST16) {
	macro_sbb16(s_eaw1, d_eaw1);
}

#:SBJNZ

macro macro_SHA_imm(val, shift, msb)
{
	local d = val;
	local c_pos:1 = (shift s> 0) && (((d  << ( shift-1)) & msb) != 0);
	local c_neg:1 = (shift s< 0) && (((d s>> (-shift-1)) & 1) != 0);
	d = zext(shift s> 0 )*(d << shift) + zext(shift s< 0)*(d >> (-shift));
	Sflg = (d s< 0);
	Zflg = (d == 0);
	Cflg = c_pos || c_neg;
	val = d;
}
:SHA.w sha_imm12_15, d_eaw         is (op1_7=0x78 & size0=1 & sha_imm12_15) ... & d_eaw {
	macro_SHA_imm(d_eaw, sha_imm12_15:1, 0x8000);
}
:SHA.L shl_imm8_11, dest_SHAL_12   is (op0_7=0xEB & op13_15=0x5 & dest_SHAL_12 & shl_imm8_11) {
	macro_SHA_imm(dest_SHAL_12, shl_imm8_11:1, 0x80000000);
}

macro macro_SHA_R1H(d_eaX, msb)
{
	local d = d_eaX;
	if (R1H s> 0) goto <shiftleft>;
		Cflg = ((d >> (-R1H-1)) & 0x0001) != 0;
		d = d s>> (-R1H);
		goto <done>;
	<shiftleft>
		Cflg = ((d << (R1H-1)) & msb) != 0;
		d = d << R1H;
	<done>
	Sflg = (d s< 0);
	Zflg = (d == 0);
	d_eaX = d;
}
:SHA.w R1H, d_eaw                  is (R1H & op1_7=0x3A & size0=1 & op12_15=0x0F)  ... & d_eaw {
	macro_SHA_R1H(d_eaw, 0x8000);
}
:SHA.b R1H, d_eab                  is (R1H & op1_7=0x3A & size0=0 & op12_15=0x0F)  ... & d_eab {
	macro_SHA_R1H(d_eab, 0x80);
}
:SHA.L R1H, dest_SHAL_12           is (R1H & op0_7=0xEB & op13_15=0x1 & dest_SHAL_12 & op8_11=0xF) {
	macro_SHA_R1H(dest_SHAL_12, 0x80000000);
}

macro macro_SHL(val, shift, msb)
{
	local d = val;
	local c_pos:1 = (shift s> 0) && (((d << ( shift-1)) & msb) != 0);
	local c_neg:1 = (shift s< 0) && (((d >> (-shift-1)) & 1) != 0);
	d = zext(shift s> 0)*(d << shift) + zext(shift s< 0)*(d >> (-shift));
	Sflg = (d s< 0);
	Zflg = (d == 0);
	Cflg = c_pos || c_neg;
	val = d;
}
:SHL.b sha_imm12_15, d_eab         is (op1_7=0x74 & size0=0 & sha_imm12_15) ... & d_eab {
	macro_SHL(d_eab, sha_imm12_15:1, 0x80);
}
:SHL.w sha_imm12_15, d_eaw         is (op1_7=0x74 & size0=1 & sha_imm12_15) ... & d_eaw {
	macro_SHL(d_eaw, sha_imm12_15:1, 0x8000);
}
:SHL.b R1H, d_eab                  is (R1H & op1_7=0x3A & size0=0 & op12_15=0x0E) ... & d_eab {
	macro_SHL(d_eab, R1H, 0x80);
}
:SHL.w R1H, d_eaw                  is (R1H & op1_7=0x3A & size0=1 & op12_15=0x0E)  ... & d_eaw {
	macro_SHL(d_eaw, R1H, 0x8000);
}

:SHL.L shl_imm8_11, R2R0           is R2R0 & op0_7=0xEB & op12_15=0x08 & shl_imm8_11 {
	macro_SHL(R2R0, shl_imm8_11:1, 0x80000000);
}
:SHL.L shl_imm8_11, R3R1           is R3R1 & op0_7=0xEB & op12_15=0x09 & shl_imm8_11 {
	macro_SHL(R3R1, shl_imm8_11:1, 0x80000000);
}
:SHL.L R1H, R2R0                   is R1H & R2R0 & op0_7=0xEB &  op12_15=0x0 & shl_imm8_11 {
	macro_SHL(R2R0, R1H, 0x80000000);
}
:SHL.l R1H, R3R1                   is R1H & R3R1 & op0_7=0xEB & op12_15=0x01 & shl_imm8_11 {
	macro_SHL(R3R1, R1H, 0x80000000);
}


:SMOVF.b                           is op1_7=0x3E & size0=0 & op8_15=0xE8 {
	local dest_addr:2 = A1;
	local src_addr:4 = (zext(R1H) << 16) | zext(A0);
	<loopstart>
	if(R3 == 0) goto <end>;
	*[near]:1 dest_addr = *:1 src_addr;
	dest_addr = dest_addr+1;
	src_addr = src_addr+1;
	R3 = R3-1;
	goto <loopstart>;
	<end>
	A1 = dest_addr;
	local tmp = src_addr >> 16;
	R1H = tmp:1;
	A0 = src_addr:2;
}

:SMOVF.w                           is op1_7=0x3E & size0=1 & op8_15=0xE8 {
	local dest_addr:2 = A1;
	local src_addr:4 = (zext(R1H) << 16) | zext(A0);
	<loopstart>
	if(R3 == 0) goto <end>;
	*[near]:2 dest_addr = *:2 src_addr;
	dest_addr = dest_addr+2;
	src_addr = src_addr+2;
	R3 = R3-1;
	goto <loopstart>;
	<end>
	A1 = dest_addr;
	local tmp = src_addr >> 16;
	R1H = tmp:1;
	A0 = src_addr:2;
}

:SSTR.b                            is op1_7=0x3E & size0=0 & op8_15=0xEA {
	local addr:2 = A1;
	<loopstart>
	if(R3 == 0) goto <end>;
	*[near]:1 addr = R0L;
	addr = addr+1;
	R3 = R3-1;
	goto <loopstart>;
	<end>
	A1 = addr;
}

:SSTR.w                            is op1_7=0x3E & size0=1 & op8_15=0xEA {
	local addr:2 = A1;
	<loopstart>
	if(R3 == 0) goto <end>;
	*[near]:2 addr = R0;
	addr = addr+2;
	R3 = R3-1;
	goto <loopstart>;
	<end>
	A1 = addr;
}

:STC ldc12_14, d_eaw               is (op0_7=0x7B & bit15=1 & ldc12_14) ... & d_eaw {
	d_eaw = ldc12_14;
}
# FIXME implement destinations other than R2R0, R3R1, A1A0
:STC "PC", src32_8_11              is (op0_7=0x7C & op12_15=0xC & src32_8_11) {
	src32_8_11 = inst_start;
}

# TODO: Implement STCTX
define pcodeop STORE_CONTEXT;

:STCTX abs16, abs20                is op0_15=0xF07D; abs16; abs20 {
	STORE_CONTEXT(abs16:2, abs20:3);
}


:STE.b dest8_11, abs20             is op1_7=0x3A & size0=0 & op12_15=0x00 & dest8_11 & $(DEST_IS_An); abs20 {
	local addr:4 = zext(abs20:3);
	*:1 addr = dest8_11:1;
	Sflg = (dest8_11 s< 0);
	Zflg = (dest8_11 == 0);
}

:STE.b d_eab, abs20                is (op1_7=0x3A & size0=0 & op12_15=0x00) ... & d_eab; abs20 {
	local addr:4 = zext(abs20:3);
	*:1 addr = d_eab:1;
	Sflg = (d_eab s< 0);
	Zflg = (d_eab == 0);
}

:STE.w d_eaw, abs20                is (op1_7=0x3A & size0=1 & op12_15=0x00) ... & d_eaw; abs20 {
	local addr:4 = zext(abs20:3);
	*:2 addr = d_eaw;
	Sflg = (d_eaw s< 0);
	Zflg = (d_eaw == 0);
}

:STE.b dest8_11, addr              is op1_7=0x3A & size0=0 & op12_15=0x01 & dest8_11 & $(DEST_IS_An); abs20 [addr = A0+abs20;] {
	*:1 addr:4 = dest8_11:1;
	Sflg = (dest8_11 s< 0);
	Zflg = (dest8_11 == 0);
}

:STE.b d_eab, addr                 is (op1_7=0x3A & size0=0 & op12_15=0x01) ... & d_eab; abs20 [addr = A0+abs20;] {
	*:1 addr:4 = d_eab:1;
	Sflg = (d_eab s< 0);
	Zflg = (d_eab == 0);
}

:STE.w d_eaw, addr                 is (op1_7=0x3A & size0=1 & op12_15=0x01) ... & d_eaw; abs20 [addr = A0+abs20;] {
	*:2 addr:4 = d_eaw;
	Sflg = (d_eaw s< 0);
	Zflg = (d_eaw == 0);
}

:STE.b dest8_11, A1A0              is A1A0 & op1_7=0x3A & size0=0 & op12_15=0x02 & dest8_11 & $(DEST_IS_An) {
	*:1 A1A0 = dest8_11:1;
	Sflg = (dest8_11 s< 0);
	Zflg = (dest8_11 == 0);
}

:STE.b d_eab, A1A0                 is (A1A0 & op1_7=0x3A & size0=0 & op12_15=0x02) ... & d_eab {
	*:1 A1A0 = d_eab:1;
	Sflg = (d_eab s< 0);
	Zflg = (d_eab == 0);
}

:STE.w d_eaw, A1A0                 is (A1A0 &op1_7=0x3A & size0=1 & op12_15=0x02) ... & d_eaw {
	*:2 A1A0 = d_eaw;
	Sflg = (d_eaw s< 0);
	Zflg = (d_eaw == 0);
}

:STNZ imm8_15, d_imm                is (op3_7_imm8=0x1A & imm8_15 ) ... & d_imm {
	if (Zflg) goto <end>;
	d_imm = imm8_15;
	<end>
}

:STZ imm8_15, d_imm                is (op3_7_imm8=0x19 & imm8_15 ) ... & d_imm {
	if (!Zflg) goto <end>;
	d_imm = imm8_15;
	<end>
}

:STZX imm8_15, imm8, d_imm         is (op3_7_imm8=0x1b & imm8_15) ... & d_imm; imm8 {
	if (!Zflg) goto <Zfalse>;
		# Z = true
		d_imm = imm8_15;
		goto <end>;
	<Zfalse>
		d_imm = imm8;
	<end>
}


:SUB.b u8, dest8_11                is op1_7=0x3B & size0=0 & op12_15=0x05 & dest8_11 & $(DEST_IS_An); u8 {
	macro_sub(zext(u8), dest8_11);
}

:SUB.b u8, d_eab                   is (op1_7=0x3B & size0=0 & op12_15=0x05) ... & d_eab; u8 {
	macro_sub(u8, d_eab);
}

:SUB.w u16, d_eaw                  is (op1_7=0x3B & size0=1 & op12_15=0x05) ... & d_eaw; u16 {
	macro_sub(u16, d_eaw);
}


:SUB.b imm8_15, d_imm              is (op3_7_imm8=0x11 & imm8_15) ... & d_imm {
	macro_sub(imm8_15, d_imm);
}


:SUB.b s_eab, dest8_11             is (op1_7=0x54 & size0=0 &src12_15 & dest8_11 & $(DEST_IS_An)) ... & s_eab {
	macro_sub(zext(s_eab), dest8_11);
}

:SUB.b s_eab1, d_eab1              is op1_7=0x54 & size0=0 & $(SRCDEST8) {
	macro_sub(s_eab1, d_eab1);
}

:SUB.w s_eaw1, d_eaw1              is op1_7=0x54 & size0=1 &$(SRCDEST16) {
	macro_sub(s_eaw1, d_eaw1);
}

:SUB.b SRC2, dest2_2               is (op=0x05 & dest2_2) ... & SRC2 {
	macro_sub(SRC2, dest2_2);
}

:TST.b u8, dest8_11                is op0_7=0x76 & op12_15=0 & dest8_11 & (dest8_11=4|dest8_11=5); u8 {
	local tmp = dest8_11 & zext(u8);
	Sflg = (tmp s< 0);
	Zflg = (tmp == 0);
}

# TODO, need to handle special case when comparing A0/A1
:TST.b u8, d_eab                 is (op0_7=0x76 & op12_15=0) ...& d_eab; u8 {
	local tmp = d_eab & u8;
	Sflg = (tmp s< 0);
	Zflg = (tmp == 0);
}

:TST.w u16, d_eaw                is (op1_7=0x3B & size0=1 & op12_15=0) ... & d_eaw ; u16 {
	local tmp = d_eaw & u16;
	Sflg = (tmp s< 0);
	Zflg = (tmp == 0);
}

:TST.b s_eab, dest8_11             is (op1_7=0x40 & size0=0 & dest8_11 & $(DEST_IS_An)) ... & s_eab {
	local tmp = dest8_11 & zext(s_eab);
	Sflg = (tmp s< 0);
	Zflg = (tmp == 0);
}


:TST.b s_eab1, d_eab1              is op1_7=0x40 & size0=0 &$(SRCDEST8) {
	local tmp = d_eab1 & s_eab1;
	Sflg = (tmp s< 0);
	Zflg = (tmp == 0);
}

:TST.w s_eaw1, d_eaw1              is op1_7=0x40 & size0=1 & $(SRCDEST16) {
	local tmp = d_eaw1 & s_eaw1;
	Sflg = (tmp s< 0);
	Zflg = (tmp == 0);
}


:XCHG srcb12_13, dest8_11          is op1_7=0x3D & size0=0 & bit15=0 & bit14=0 & srcb12_13 & dest8_11 & $(DEST_IS_An) {
	local temp:1 = dest8_11:1;
	dest8_11 = zext(srcb12_13:1);
	srcb12_13 = temp;
}

:XCHG srcb12_13, d_eab             is (op1_7=0x3D & size0=0 & bit15=0 & bit14=0 & srcb12_13) ... & d_eab {
	local temp:1 = d_eab;
	d_eab = srcb12_13;
	srcb12_13 = temp;
}

:XCHG srcw12_13, d_eaw             is (op1_7=0x3D & size0=1 & bit15=0 & bit14=0 & srcw12_13) ... & d_eaw {
	local temp:2 = d_eaw;
	d_eaw= srcw12_13;
	srcw12_13 = temp;
}


:XOR.b u8, dest8_11                is op1_7=0x3B & size0=0 & op12_15=0x01 & dest8_11 & $(DEST_IS_An); u8 {
	dest8_11 = dest8_11 ^ zext(u8:1);
	Zflg = (dest8_11 == 0);
	Sflg = (dest8_11 s< 0);
}

:XOR.b u8, d_eab                   is (op1_7=0x3B & size0=0 & op12_15=0x01) ... & d_eab; u8 {
	d_eab = d_eab ^ u8;
	Zflg = (d_eab == 0);
	Sflg = (d_eab s< 0);
}

:XOR.w u16, d_eaw                  is (op1_7=0x3B & size0=1 & op12_15=0x01) ... & d_eaw; u16 {
	d_eaw = d_eaw ^ u16;
	Zflg = (d_eaw == 0);
	Sflg = (d_eaw s< 0);
}

:XOR.b s_eab, dest8_11             is op1_7=0x44 & size0=0 & op12_15=0x01 & dest8_11 & $(DEST_IS_An); s_eab {
	dest8_11 = dest8_11 ^ zext(s_eab:1);
	Zflg = (dest8_11 == 0);
	Sflg = (dest8_11 s< 0);
}

:XOR.b s_eab1, d_eab1              is op1_7=0x44 & size0=0 & $(SRCDEST8) {
	d_eab1 = d_eab1 ^ s_eab1;
	Zflg = (d_eab1 == 0);
	Sflg = (d_eab1 s< 0);
}

:XOR.w s_eaw1, d_eaw1              is op1_7=0x44 & size0=1 & $(SRCDEST16) {
	d_eaw1 = d_eaw1 ^ s_eaw1;
	Zflg = (d_eaw1 == 0);
	Sflg = (d_eaw1 s< 0);
}

